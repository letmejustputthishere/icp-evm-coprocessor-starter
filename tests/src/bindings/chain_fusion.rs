// This is an experimental feature used to generate Rust bindings from Candid.
// THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE TO AVOID DATA LOSS.
#![allow(dead_code, unused_imports, non_snake_case)]
use candid::{self, CandidType, Decode, Deserialize, Encode, Principal};

#[derive(CandidType, Deserialize)]
pub enum EcdsaCurve {
    #[serde(rename = "secp256k1")]
    Secp256K1,
}

#[derive(CandidType, Deserialize)]
pub struct EcdsaKeyId {
    pub name: String,
    pub curve: EcdsaCurve,
}

#[derive(CandidType, Deserialize)]
pub enum L2MainnetService {
    Alchemy,
    BlockPi,
    PublicNode,
    Ankr,
}

#[derive(CandidType, Deserialize)]
pub struct HttpHeader {
    pub value: String,
    pub name: String,
}

#[derive(CandidType, Deserialize)]
pub struct RpcApi {
    pub url: String,
    pub headers: Option<Vec<HttpHeader>>,
}

#[derive(CandidType, Deserialize)]
pub enum EthMainnetService {
    Alchemy,
    BlockPi,
    Cloudflare,
    PublicNode,
    Ankr,
}

#[derive(CandidType, Deserialize)]
pub enum RpcService {
    EthSepolia(L2MainnetService),
    BaseMainnet(L2MainnetService),
    Custom(RpcApi),
    OptimismMainnet(L2MainnetService),
    ArbitrumOne(L2MainnetService),
    EthMainnet(EthMainnetService),
    Chain(u64),
    Provider(u64),
}

#[derive(CandidType, Deserialize)]
pub struct InitArg {
    pub ecdsa_key_id: EcdsaKeyId,
    pub rpc_service: RpcService,
    pub filter_addresses: Vec<String>,
    pub chain_id: u64,
    pub coprocessor_evm_address: String,
    pub filter_events: Vec<String>,
}

pub struct ChainFusionCanister {
    pub canister_id: Principal,
    pub caller: super::Caller,
}

impl ChainFusionCanister {
    pub fn get_evm_address(&self) -> super::CallBuilder<Option<String>> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "get_evm_address",
            args,
        )
    }
}
pub const CANISTER_ID: Principal = Principal::from_slice(&[0, 0, 0, 0, 0, 160, 190, 169, 1, 1]); // 2222s-4iaaa-aaaaf-ax2uq-cai

pub fn new(caller: &super::Caller, canister_id: Principal) -> ChainFusionCanister {
    ChainFusionCanister {
        canister_id,
        caller: caller.clone(),
    }
}

pub fn deploy(
    deployer: &super::Deployer,
    arg0: InitArg,
) -> super::DeployBuilder<ChainFusionCanister> {
    let args = Encode!(&arg0);
    let result = deployer.deploy(args, new);
    let result = if let Some(id) = canister_id() {
        result.with_canister_id(id)
    } else {
        result
    };
    if let Some(wasm) = wasm() {
        result.with_wasm(wasm)
    } else {
        result
    }
}
pub fn canister_id() -> Option<Principal> {
    Some(Principal::from_text("2222s-4iaaa-aaaaf-ax2uq-cai").unwrap())
}

pub fn wasm() -> Option<Vec<u8>> {
    let mut path = std::path::PathBuf::new();
    path.push("../.dfx/local/canisters/chain_fusion/chain_fusion.wasm");
    let wasm = std::fs::read(path.as_path())
        .unwrap_or_else(|_| panic!("wasm binary not found: {:?}", path));
    Some(wasm)
}
